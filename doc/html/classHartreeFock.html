<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.7"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>IM-SRG++: HartreeFock Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">IM-SRG++<span id="projectnumber">&#160;0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.7 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="classHartreeFock-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">HartreeFock Class Reference</div></div>
</div><!--header-->
<div class="contents">
<div class="dynheader">
Inheritance diagram for HartreeFock:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classHartreeFock.png" usemap="#HartreeFock_map" alt=""/>
  <map id="HartreeFock_map" name="HartreeFock_map">
<area href="classHFMBPT.html" alt="HFMBPT" shape="rect" coords="0,56,83,80"/>
  </map>
</div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ad39d695b75dc9c6aa2f0e1ff81d1adc5"><td class="memItemLeft" align="right" valign="top"><a id="ad39d695b75dc9c6aa2f0e1ff81d1adc5" name="ad39d695b75dc9c6aa2f0e1ff81d1adc5"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>HartreeFock</b> (<a class="el" href="classOperator.html">Operator</a> &amp;hbare)</td></tr>
<tr class="memdesc:ad39d695b75dc9c6aa2f0e1ff81d1adc5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor. <br /></td></tr>
<tr class="separator:ad39d695b75dc9c6aa2f0e1ff81d1adc5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d6bac9b4403e4bc599a89ad0c9b6056"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHartreeFock.html#a3d6bac9b4403e4bc599a89ad0c9b6056">BuildMonopoleV</a> ()</td></tr>
<tr class="memdesc:a3d6bac9b4403e4bc599a89ad0c9b6056"><td class="mdescLeft">&#160;</td><td class="mdescRight">Only the monopole part of V is needed, so construct it.  <br /></td></tr>
<tr class="separator:a3d6bac9b4403e4bc599a89ad0c9b6056"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a608db2a6188579180d6fc51230a4aa3e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHartreeFock.html#a608db2a6188579180d6fc51230a4aa3e">SetUpMonopoleV3Keys</a> ()</td></tr>
<tr class="memdesc:a608db2a6188579180d6fc51230a4aa3e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Figure out the needed monopole terms.  <br /></td></tr>
<tr class="separator:a608db2a6188579180d6fc51230a4aa3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c146af25a09f427cc626d877ec6e518"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHartreeFock.html#a1c146af25a09f427cc626d877ec6e518">BuildMonopoleV3</a> ()</td></tr>
<tr class="memdesc:a1c146af25a09f427cc626d877ec6e518"><td class="mdescLeft">&#160;</td><td class="mdescRight">Only the monopole part of V3 is needed.  <br /></td></tr>
<tr class="separator:a1c146af25a09f427cc626d877ec6e518"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a1bd3a195362c73e6c9e10a38fcb13b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHartreeFock.html#a0a1bd3a195362c73e6c9e10a38fcb13b">BuildMonopoleV3Jacobi</a> ()</td></tr>
<tr class="memdesc:a0a1bd3a195362c73e6c9e10a38fcb13b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct directly from the Jacobi 3-body matrix elements.  <br /></td></tr>
<tr class="separator:a0a1bd3a195362c73e6c9e10a38fcb13b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00f7b0c4cb7373a3f1a69ca27a4dfaed"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHartreeFock.html#a00f7b0c4cb7373a3f1a69ca27a4dfaed">Diagonalize</a> ()</td></tr>
<tr class="memdesc:a00f7b0c4cb7373a3f1a69ca27a4dfaed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Diagonalize the Fock matrix.  <br /></td></tr>
<tr class="separator:a00f7b0c4cb7373a3f1a69ca27a4dfaed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84fe0eb16f6e5835c920bf8fa98c4442"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHartreeFock.html#a84fe0eb16f6e5835c920bf8fa98c4442">UpdateF</a> ()</td></tr>
<tr class="memdesc:a84fe0eb16f6e5835c920bf8fa98c4442"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update the Fock matrix with the new transformation coefficients C.  <br /></td></tr>
<tr class="separator:a84fe0eb16f6e5835c920bf8fa98c4442"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad38c905e7e9f9e9757b5800e6910c61"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHartreeFock.html#aad38c905e7e9f9e9757b5800e6910c61">UpdateDensityMatrix</a> ()</td></tr>
<tr class="memdesc:aad38c905e7e9f9e9757b5800e6910c61"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update the density matrix with the new coefficients C.  <br /></td></tr>
<tr class="separator:aad38c905e7e9f9e9757b5800e6910c61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1eb3f52619f55db878f9e465265aa698"><td class="memItemLeft" align="right" valign="top"><a id="a1eb3f52619f55db878f9e465265aa698" name="a1eb3f52619f55db878f9e465265aa698"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>UpdateDensityMatrix_DIIS</b> ()</td></tr>
<tr class="memdesc:a1eb3f52619f55db878f9e465265aa698"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update the density matrix using Direct Inversion in Iterative Subspace. <br /></td></tr>
<tr class="separator:a1eb3f52619f55db878f9e465265aa698"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74c842cbf4e8caec72591c1205794f1f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHartreeFock.html#a74c842cbf4e8caec72591c1205794f1f">FillLowestOrbits</a> ()</td></tr>
<tr class="memdesc:a74c842cbf4e8caec72591c1205794f1f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get new occupations based on the current single-particle energies.  <br /></td></tr>
<tr class="separator:a74c842cbf4e8caec72591c1205794f1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7dbc7d8aa192f192f23347c46ad084c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHartreeFock.html#af7dbc7d8aa192f192f23347c46ad084c">UpdateReference</a> ()</td></tr>
<tr class="memdesc:af7dbc7d8aa192f192f23347c46ad084c"><td class="mdescLeft">&#160;</td><td class="mdescRight">If we got new occupations in FillLowestOrbits, then we should update the hole states in the reference.  <br /></td></tr>
<tr class="separator:af7dbc7d8aa192f192f23347c46ad084c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35ab9c4f96e68b1c9acea1d1407ecc60"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHartreeFock.html#a35ab9c4f96e68b1c9acea1d1407ecc60">CheckConvergence</a> ()</td></tr>
<tr class="memdesc:a35ab9c4f96e68b1c9acea1d1407ecc60"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare the current energies with those from the previous iteration.  <br /></td></tr>
<tr class="separator:a35ab9c4f96e68b1c9acea1d1407ecc60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0666507747c17845ab4f74b97414703c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHartreeFock.html#a0666507747c17845ab4f74b97414703c">Solve</a> ()</td></tr>
<tr class="memdesc:a0666507747c17845ab4f74b97414703c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Diagonalize and UpdateF until convergence.  <br /></td></tr>
<tr class="separator:a0666507747c17845ab4f74b97414703c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef506c5c5bc0f317ceb9c71bdc44d62b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHartreeFock.html#aef506c5c5bc0f317ceb9c71bdc44d62b">CalcEHF</a> ()</td></tr>
<tr class="memdesc:aef506c5c5bc0f317ceb9c71bdc44d62b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluate the Hartree Fock energy.  <br /></td></tr>
<tr class="separator:aef506c5c5bc0f317ceb9c71bdc44d62b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c3bdda2ea86f9a3b18d203c9aecc353"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHartreeFock.html#a2c3bdda2ea86f9a3b18d203c9aecc353">PrintEHF</a> ()</td></tr>
<tr class="memdesc:a2c3bdda2ea86f9a3b18d203c9aecc353"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print out the Hartree Fock energy.  <br /></td></tr>
<tr class="separator:a2c3bdda2ea86f9a3b18d203c9aecc353"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2eb6754f57250a03a2e1bd3e2aef4daf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHartreeFock.html#a2eb6754f57250a03a2e1bd3e2aef4daf">ReorderCoefficients</a> ()</td></tr>
<tr class="memdesc:a2eb6754f57250a03a2e1bd3e2aef4daf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reorder the coefficients in C to eliminate phases etc.  <br /></td></tr>
<tr class="separator:a2eb6754f57250a03a2e1bd3e2aef4daf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94e029d6a9091ed2dbf1b1b54a03ceb7"><td class="memItemLeft" align="right" valign="top"><a id="a94e029d6a9091ed2dbf1b1b54a03ceb7" name="a94e029d6a9091ed2dbf1b1b54a03ceb7"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>SetJacobi3BME</b> (<a class="el" href="classJacobi3BME.html">Jacobi3BME</a> *jac)</td></tr>
<tr class="separator:a94e029d6a9091ed2dbf1b1b54a03ceb7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d0fda17b0ddf45fe25ac49b26247104"><td class="memItemLeft" align="right" valign="top"><a id="a4d0fda17b0ddf45fe25ac49b26247104" name="a4d0fda17b0ddf45fe25ac49b26247104"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>DiscardNO2Bfrom3N</b> ()</td></tr>
<tr class="memdesc:a4d0fda17b0ddf45fe25ac49b26247104"><td class="mdescLeft">&#160;</td><td class="mdescRight">Setter. <br /></td></tr>
<tr class="separator:a4d0fda17b0ddf45fe25ac49b26247104"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55914915cea16669e549025c244b62d0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classOperator.html">Operator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHartreeFock.html#a55914915cea16669e549025c244b62d0">TransformToHFBasis</a> (<a class="el" href="classOperator.html">Operator</a> &amp;OpIn)</td></tr>
<tr class="memdesc:a55914915cea16669e549025c244b62d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transform an operator from oscillator basis to HF basis.  <br /></td></tr>
<tr class="separator:a55914915cea16669e549025c244b62d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af548b32924c2dfcd885ca0ba95525a82"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classOperator.html">Operator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHartreeFock.html#af548b32924c2dfcd885ca0ba95525a82">GetNormalOrderedH</a> (int particle_rank=2)</td></tr>
<tr class="memdesc:af548b32924c2dfcd885ca0ba95525a82"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the Hamiltonian in the HF basis at the normal-ordered 2body level.  <br /></td></tr>
<tr class="separator:af548b32924c2dfcd885ca0ba95525a82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5aa5a7db5250b37f6e2527c470bd1164"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classOperator.html">Operator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHartreeFock.html#a5aa5a7db5250b37f6e2527c470bd1164">GetNormalOrderedH</a> (arma::mat &amp;Cin, int particle_rank=2)</td></tr>
<tr class="memdesc:a5aa5a7db5250b37f6e2527c470bd1164"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the Hamiltonian in the HF basis at the normal-ordered 2body level.  <br /></td></tr>
<tr class="separator:a5aa5a7db5250b37f6e2527c470bd1164"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53011b381945ed5c61f50b209db5bf64"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classOperator.html">Operator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHartreeFock.html#a53011b381945ed5c61f50b209db5bf64">GetOmega</a> ()</td></tr>
<tr class="memdesc:a53011b381945ed5c61f50b209db5bf64"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a generator of the Hartree Fock transformation.  <br /></td></tr>
<tr class="separator:a53011b381945ed5c61f50b209db5bf64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f2a07edc3ccaa0cf9bbc0faadfd9ddf"><td class="memItemLeft" align="right" valign="top"><a id="a7f2a07edc3ccaa0cf9bbc0faadfd9ddf" name="a7f2a07edc3ccaa0cf9bbc0faadfd9ddf"></a>
<a class="el" href="classOperator.html">Operator</a>&#160;</td><td class="memItemRight" valign="bottom"><b>GetHbare</b> ()</td></tr>
<tr class="separator:a7f2a07edc3ccaa0cf9bbc0faadfd9ddf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab96b85eca26bf7c57430242201066932"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHartreeFock.html#ab96b85eca26bf7c57430242201066932">PrintSPE</a> ()</td></tr>
<tr class="memdesc:ab96b85eca26bf7c57430242201066932"><td class="mdescLeft">&#160;</td><td class="mdescRight">Getter function for Hbare.  <br /></td></tr>
<tr class="separator:ab96b85eca26bf7c57430242201066932"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51d5163a8df635593edbeaa531aa5a34"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHartreeFock.html#a51d5163a8df635593edbeaa531aa5a34">PrintSPEandWF</a> ()</td></tr>
<tr class="memdesc:a51d5163a8df635593edbeaa531aa5a34"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print out the single-particle energies and wave functions.  <br /></td></tr>
<tr class="separator:a51d5163a8df635593edbeaa531aa5a34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef3c1b45c5418ead19f258774a301f83"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHartreeFock.html#aef3c1b45c5418ead19f258774a301f83">FreeVmon</a> ()</td></tr>
<tr class="memdesc:aef3c1b45c5418ead19f258774a301f83"><td class="mdescLeft">&#160;</td><td class="mdescRight">Free up the memory used to store Vmon3.  <br /></td></tr>
<tr class="separator:aef3c1b45c5418ead19f258774a301f83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a948748d946c4186bce3252a6be2076df"><td class="memItemLeft" align="right" valign="top"><a id="a948748d946c4186bce3252a6be2076df" name="a948748d946c4186bce3252a6be2076df"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>GetRadialWF</b> (index_t index, std::vector&lt; double &gt; &amp;R, std::vector&lt; double &gt; &amp;PSI)</td></tr>
<tr class="memdesc:a948748d946c4186bce3252a6be2076df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the radial wave function of an orbit in the HF basis. <br /></td></tr>
<tr class="separator:a948748d946c4186bce3252a6be2076df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29de897a332985f5b08bd0f08a466db3"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHartreeFock.html#a29de897a332985f5b08bd0f08a466db3">GetRadialWF_r</a> (index_t index, double R)</td></tr>
<tr class="memdesc:a29de897a332985f5b08bd0f08a466db3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the radial wave function of an orbit in the HF basis.  <br /></td></tr>
<tr class="separator:a29de897a332985f5b08bd0f08a466db3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a212670984cab16c79f1c4cfd376f8e3d"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHartreeFock.html#a212670984cab16c79f1c4cfd376f8e3d">GetHFPotential</a> (size_t i, double r, double rprime)</td></tr>
<tr class="separator:a212670984cab16c79f1c4cfd376f8e3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab893ac9710d1b5ce8797d55d99fd5f9"><td class="memItemLeft" align="right" valign="top"><a id="aab893ac9710d1b5ce8797d55d99fd5f9" name="aab893ac9710d1b5ce8797d55d99fd5f9"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><b>GetAverageHFPotential</b> (double r, double rprime)</td></tr>
<tr class="separator:aab893ac9710d1b5ce8797d55d99fd5f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3fb9fc68d98aedc4cf1aae52da237339"><td class="memItemLeft" align="right" valign="top"><a id="a3fb9fc68d98aedc4cf1aae52da237339" name="a3fb9fc68d98aedc4cf1aae52da237339"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>FreezeOccupations</b> ()</td></tr>
<tr class="separator:a3fb9fc68d98aedc4cf1aae52da237339"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7aa734d2b1df54ddba236f279269fcc"><td class="memItemLeft" align="right" valign="top"><a id="ab7aa734d2b1df54ddba236f279269fcc" name="ab7aa734d2b1df54ddba236f279269fcc"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>UnFreezeOccupations</b> ()</td></tr>
<tr class="separator:ab7aa734d2b1df54ddba236f279269fcc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9b00d4cece0e9424b09bd5faaef8276"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHartreeFock.html#ab9b00d4cece0e9424b09bd5faaef8276">Vmon3JacobiHash</a> (uint64_t na, uint64_t nb, uint64_t nc, uint64_t Jab, uint64_t twoJ, uint64_t E12, uint64_t alpha, uint64_t Ncm, uint64_t Lcm)</td></tr>
<tr class="separator:ab9b00d4cece0e9424b09bd5faaef8276"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62997db6f9334dbe83c191aec4ab127d"><td class="memItemLeft" align="right" valign="top"><a id="a62997db6f9334dbe83c191aec4ab127d" name="a62997db6f9334dbe83c191aec4ab127d"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>Vmon3JacobiUnHash</b> (uint64_t key, uint64_t &amp;na, uint64_t &amp;nb, uint64_t &amp;nc, uint64_t &amp;Jab, uint64_t &amp;twoJ, uint64_t &amp;E12, uint64_t &amp;alpha, uint64_t &amp;Ncm, uint64_t &amp;Lcm)</td></tr>
<tr class="memdesc:a62997db6f9334dbe83c191aec4ab127d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Take a hashed key and extract the six orbit indices that went into it. <br /></td></tr>
<tr class="separator:a62997db6f9334dbe83c191aec4ab127d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aefe4589d4659b6c18e75d8029d8293dd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classThreeBodyME.html">ThreeBodyME</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHartreeFock.html#aefe4589d4659b6c18e75d8029d8293dd">GetTransformed3B</a> (<a class="el" href="classOperator.html">Operator</a> &amp;OpIn, arma::mat &amp;C3b)</td></tr>
<tr class="separator:aefe4589d4659b6c18e75d8029d8293dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28d6ea079a6e83db7f5c3a85d8422c41"><td class="memItemLeft" align="right" valign="top"><a id="a28d6ea079a6e83db7f5c3a85d8422c41" name="a28d6ea079a6e83db7f5c3a85d8422c41"></a>
<a class="el" href="classThreeBodyME.html">ThreeBodyME</a>&#160;</td><td class="memItemRight" valign="bottom"><b>GetValence3B</b> (<a class="el" href="classOperator.html">Operator</a> &amp;OpIn, int emax, int E3max)</td></tr>
<tr class="separator:a28d6ea079a6e83db7f5c3a85d8422c41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76d1edc5c03fdee691828855ecaa70d2"><td class="memItemLeft" align="right" valign="top"><a id="a76d1edc5c03fdee691828855ecaa70d2" name="a76d1edc5c03fdee691828855ecaa70d2"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><b>GetTransformed3bme</b> (<a class="el" href="classOperator.html">Operator</a> &amp;OpIn, int Jab, int Jde, int J2, size_t a, size_t b, size_t c, size_t d, size_t e, size_t f)</td></tr>
<tr class="separator:a76d1edc5c03fdee691828855ecaa70d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac74c8fb568eae94cb191bf3fa7cad574"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHartreeFock.html#ac74c8fb568eae94cb191bf3fa7cad574">SetModelspaceForOutput3N</a> (<a class="el" href="classModelSpace.html">ModelSpace</a> &amp;ms)</td></tr>
<tr class="separator:ac74c8fb568eae94cb191bf3fa7cad574"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-static-methods" name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:ab863d5d020e15854d4d591ec0ce6a1a0"><td class="memItemLeft" align="right" valign="top">static uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHartreeFock.html#ab863d5d020e15854d4d591ec0ce6a1a0">Vmon3Hash</a> (uint64_t a, uint64_t b, uint64_t c, uint64_t d, uint64_t e, uint64_t f)</td></tr>
<tr class="separator:ab863d5d020e15854d4d591ec0ce6a1a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af675589807ed0369ce3c9ef30d9d625b"><td class="memItemLeft" align="right" valign="top"><a id="af675589807ed0369ce3c9ef30d9d625b" name="af675589807ed0369ce3c9ef30d9d625b"></a>
static void&#160;</td><td class="memItemRight" valign="bottom"><b>Vmon3UnHash</b> (uint64_t key, int &amp;a, int &amp;b, int &amp;c, int &amp;d, int &amp;e, int &amp;f)</td></tr>
<tr class="memdesc:af675589807ed0369ce3c9ef30d9d625b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Take a hashed key and extract the six orbit indices that went into it. <br /></td></tr>
<tr class="separator:af675589807ed0369ce3c9ef30d9d625b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-attribs" name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:aad1a5eeadedf9689bbfc2e3d71b60aee"><td class="memItemLeft" align="right" valign="top"><a id="aad1a5eeadedf9689bbfc2e3d71b60aee" name="aad1a5eeadedf9689bbfc2e3d71b60aee"></a>
<a class="el" href="classOperator.html">Operator</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>Hbare</b></td></tr>
<tr class="memdesc:aad1a5eeadedf9689bbfc2e3d71b60aee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Input bare Hamiltonian. <br /></td></tr>
<tr class="separator:aad1a5eeadedf9689bbfc2e3d71b60aee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d4a6814a338d7e4c17575ac74763f30"><td class="memItemLeft" align="right" valign="top"><a id="a5d4a6814a338d7e4c17575ac74763f30" name="a5d4a6814a338d7e4c17575ac74763f30"></a>
<a class="el" href="classModelSpace.html">ModelSpace</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>modelspace</b></td></tr>
<tr class="memdesc:a5d4a6814a338d7e4c17575ac74763f30"><td class="mdescLeft">&#160;</td><td class="mdescRight">Model Space of the Hamiltonian. <br /></td></tr>
<tr class="separator:a5d4a6814a338d7e4c17575ac74763f30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13c5555e2704c55c83c5d512fc35de78"><td class="memItemLeft" align="right" valign="top"><a id="a13c5555e2704c55c83c5d512fc35de78" name="a13c5555e2704c55c83c5d512fc35de78"></a>
<a class="el" href="classModelSpace.html">ModelSpace</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>ms_for_output_3N</b></td></tr>
<tr class="memdesc:a13c5555e2704c55c83c5d512fc35de78"><td class="mdescLeft">&#160;</td><td class="mdescRight">Model Space for the transformed 3N matrix elements (we may want a smaller space for this). <br /></td></tr>
<tr class="separator:a13c5555e2704c55c83c5d512fc35de78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c73247cdb9255cebabaacc99ec55086"><td class="memItemLeft" align="right" valign="top"><a id="a9c73247cdb9255cebabaacc99ec55086" name="a9c73247cdb9255cebabaacc99ec55086"></a>
arma::mat&#160;</td><td class="memItemRight" valign="bottom"><b>C</b></td></tr>
<tr class="memdesc:a9c73247cdb9255cebabaacc99ec55086"><td class="mdescLeft">&#160;</td><td class="mdescRight">transformation coefficients, 1st index is ho basis, 2nd = HF basis <br /></td></tr>
<tr class="separator:a9c73247cdb9255cebabaacc99ec55086"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6fc0aa9f25640979d5188443a19aeea5"><td class="memItemLeft" align="right" valign="top"><a id="a6fc0aa9f25640979d5188443a19aeea5" name="a6fc0aa9f25640979d5188443a19aeea5"></a>
arma::mat&#160;</td><td class="memItemRight" valign="bottom"><b>rho</b></td></tr>
<tr class="memdesc:a6fc0aa9f25640979d5188443a19aeea5"><td class="mdescLeft">&#160;</td><td class="mdescRight">density matrix rho_ij <br /></td></tr>
<tr class="separator:a6fc0aa9f25640979d5188443a19aeea5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa30fe3bd6fa480cc21b85a830013c9fe"><td class="memItemLeft" align="right" valign="top"><a id="aa30fe3bd6fa480cc21b85a830013c9fe" name="aa30fe3bd6fa480cc21b85a830013c9fe"></a>
arma::mat&#160;</td><td class="memItemRight" valign="bottom"><b>KE</b></td></tr>
<tr class="memdesc:aa30fe3bd6fa480cc21b85a830013c9fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">kinetic energy <br /></td></tr>
<tr class="separator:aa30fe3bd6fa480cc21b85a830013c9fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae823da58505b21231d092b3ef7cec3bf"><td class="memItemLeft" align="right" valign="top"><a id="ae823da58505b21231d092b3ef7cec3bf" name="ae823da58505b21231d092b3ef7cec3bf"></a>
arma::mat&#160;</td><td class="memItemRight" valign="bottom"><b>Vij</b></td></tr>
<tr class="memdesc:ae823da58505b21231d092b3ef7cec3bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">1 body piece of 2 body potential <br /></td></tr>
<tr class="separator:ae823da58505b21231d092b3ef7cec3bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25a0f38a655064375765f74182ce9334"><td class="memItemLeft" align="right" valign="top"><a id="a25a0f38a655064375765f74182ce9334" name="a25a0f38a655064375765f74182ce9334"></a>
arma::mat&#160;</td><td class="memItemRight" valign="bottom"><b>V3ij</b></td></tr>
<tr class="memdesc:a25a0f38a655064375765f74182ce9334"><td class="mdescLeft">&#160;</td><td class="mdescRight">1 body piece of 3 body potential <br /></td></tr>
<tr class="separator:a25a0f38a655064375765f74182ce9334"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45136295f4834a9f692f262eee75672a"><td class="memItemLeft" align="right" valign="top"><a id="a45136295f4834a9f692f262eee75672a" name="a45136295f4834a9f692f262eee75672a"></a>
arma::mat&#160;</td><td class="memItemRight" valign="bottom"><b>F</b></td></tr>
<tr class="memdesc:a45136295f4834a9f692f262eee75672a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fock matrix. <br /></td></tr>
<tr class="separator:a45136295f4834a9f692f262eee75672a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa007e1dc1d1fc8f4a24b42fc82ff277b"><td class="memItemLeft" align="right" valign="top"><a id="aa007e1dc1d1fc8f4a24b42fc82ff277b" name="aa007e1dc1d1fc8f4a24b42fc82ff277b"></a>
std::array&lt; std::array&lt; arma::mat, 2 &gt;, 3 &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>Vmon</b></td></tr>
<tr class="memdesc:aa007e1dc1d1fc8f4a24b42fc82ff277b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Monopole 2-body interaction. <br /></td></tr>
<tr class="separator:aa007e1dc1d1fc8f4a24b42fc82ff277b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ddc7c175c587f4cbf8a64b36c07e57d"><td class="memItemLeft" align="right" valign="top"><a id="a5ddc7c175c587f4cbf8a64b36c07e57d" name="a5ddc7c175c587f4cbf8a64b36c07e57d"></a>
std::array&lt; std::array&lt; arma::mat, 2 &gt;, 3 &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>Vmon_exch</b></td></tr>
<tr class="memdesc:a5ddc7c175c587f4cbf8a64b36c07e57d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Monopole 2-body interaction. <br /></td></tr>
<tr class="separator:a5ddc7c175c587f4cbf8a64b36c07e57d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9700861effb1cb3739240b76ed519141"><td class="memItemLeft" align="right" valign="top"><a id="a9700861effb1cb3739240b76ed519141" name="a9700861effb1cb3739240b76ed519141"></a>
arma::uvec&#160;</td><td class="memItemRight" valign="bottom"><b>holeorbs</b></td></tr>
<tr class="memdesc:a9700861effb1cb3739240b76ed519141"><td class="mdescLeft">&#160;</td><td class="mdescRight">list of hole orbits for generating density matrix <br /></td></tr>
<tr class="separator:a9700861effb1cb3739240b76ed519141"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c11fc0a59ceaeeb415a0e6c8d85e604"><td class="memItemLeft" align="right" valign="top"><a id="a0c11fc0a59ceaeeb415a0e6c8d85e604" name="a0c11fc0a59ceaeeb415a0e6c8d85e604"></a>
arma::rowvec&#160;</td><td class="memItemRight" valign="bottom"><b>hole_occ</b></td></tr>
<tr class="separator:a0c11fc0a59ceaeeb415a0e6c8d85e604"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a415fc1fbbba3a6a84d47e31ed18323c9"><td class="memItemLeft" align="right" valign="top">arma::vec&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHartreeFock.html#a415fc1fbbba3a6a84d47e31ed18323c9">energies</a></td></tr>
<tr class="memdesc:a415fc1fbbba3a6a84d47e31ed18323c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">occupations of hole orbits  <br /></td></tr>
<tr class="separator:a415fc1fbbba3a6a84d47e31ed18323c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43e2a195ad044947a9e1fb9f3a937d8a"><td class="memItemLeft" align="right" valign="top"><a id="a43e2a195ad044947a9e1fb9f3a937d8a" name="a43e2a195ad044947a9e1fb9f3a937d8a"></a>
arma::vec&#160;</td><td class="memItemRight" valign="bottom"><b>prev_energies</b></td></tr>
<tr class="memdesc:a43e2a195ad044947a9e1fb9f3a937d8a"><td class="mdescLeft">&#160;</td><td class="mdescRight">SPE's from last iteration. <br /></td></tr>
<tr class="separator:a43e2a195ad044947a9e1fb9f3a937d8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22c754579ad1a45f053a5305e87d4700"><td class="memItemLeft" align="right" valign="top"><a id="a22c754579ad1a45f053a5305e87d4700" name="a22c754579ad1a45f053a5305e87d4700"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><b>tolerance</b></td></tr>
<tr class="memdesc:a22c754579ad1a45f053a5305e87d4700"><td class="mdescLeft">&#160;</td><td class="mdescRight">tolerance for convergence <br /></td></tr>
<tr class="separator:a22c754579ad1a45f053a5305e87d4700"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16c9e1791919c2ceef5584bdc9b84a81"><td class="memItemLeft" align="right" valign="top"><a id="a16c9e1791919c2ceef5584bdc9b84a81" name="a16c9e1791919c2ceef5584bdc9b84a81"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><b>EHF</b></td></tr>
<tr class="memdesc:a16c9e1791919c2ceef5584bdc9b84a81"><td class="mdescLeft">&#160;</td><td class="mdescRight">Hartree-Fock energy (Normal-ordered 0-body term) <br /></td></tr>
<tr class="separator:a16c9e1791919c2ceef5584bdc9b84a81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f94913a966701c27fde108b98e89b41"><td class="memItemLeft" align="right" valign="top"><a id="a0f94913a966701c27fde108b98e89b41" name="a0f94913a966701c27fde108b98e89b41"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><b>e1hf</b></td></tr>
<tr class="memdesc:a0f94913a966701c27fde108b98e89b41"><td class="mdescLeft">&#160;</td><td class="mdescRight">One-body contribution to EHF. <br /></td></tr>
<tr class="separator:a0f94913a966701c27fde108b98e89b41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29cddead4c300ca5c3505f04e1a630bc"><td class="memItemLeft" align="right" valign="top"><a id="a29cddead4c300ca5c3505f04e1a630bc" name="a29cddead4c300ca5c3505f04e1a630bc"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><b>e2hf</b></td></tr>
<tr class="memdesc:a29cddead4c300ca5c3505f04e1a630bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Two-body contribution to EHF. <br /></td></tr>
<tr class="separator:a29cddead4c300ca5c3505f04e1a630bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89a37a2413483b1b484554c4a4f6755e"><td class="memItemLeft" align="right" valign="top"><a id="a89a37a2413483b1b484554c4a4f6755e" name="a89a37a2413483b1b484554c4a4f6755e"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><b>e3hf</b></td></tr>
<tr class="memdesc:a89a37a2413483b1b484554c4a4f6755e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Three-body contribution to EHF. <br /></td></tr>
<tr class="separator:a89a37a2413483b1b484554c4a4f6755e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7658fa0b1b05dfa7bf7b8aa7e5fd6bb3"><td class="memItemLeft" align="right" valign="top"><a id="a7658fa0b1b05dfa7bf7b8aa7e5fd6bb3" name="a7658fa0b1b05dfa7bf7b8aa7e5fd6bb3"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>iterations</b></td></tr>
<tr class="memdesc:a7658fa0b1b05dfa7bf7b8aa7e5fd6bb3"><td class="mdescLeft">&#160;</td><td class="mdescRight">iterations used in <a class="el" href="classHartreeFock.html#a0666507747c17845ab4f74b97414703c" title="Diagonalize and UpdateF until convergence.">Solve()</a> <br /></td></tr>
<tr class="separator:a7658fa0b1b05dfa7bf7b8aa7e5fd6bb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac4104112ce3a60a8fb86305df98d2e9"><td class="memItemLeft" align="right" valign="top"><a id="aac4104112ce3a60a8fb86305df98d2e9" name="aac4104112ce3a60a8fb86305df98d2e9"></a>
std::vector&lt; uint64_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>Vmon3_keys</b></td></tr>
<tr class="separator:aac4104112ce3a60a8fb86305df98d2e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7ca83cf6ad8949daffd11ba8f2c03fd"><td class="memItemLeft" align="right" valign="top"><a id="ad7ca83cf6ad8949daffd11ba8f2c03fd" name="ad7ca83cf6ad8949daffd11ba8f2c03fd"></a>
std::vector&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>Vmon3</b></td></tr>
<tr class="separator:ad7ca83cf6ad8949daffd11ba8f2c03fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0435b3f1485ddd1d8d91bbd84e008445"><td class="memItemLeft" align="right" valign="top"><a id="a0435b3f1485ddd1d8d91bbd84e008445" name="a0435b3f1485ddd1d8d91bbd84e008445"></a>
<a class="el" href="classIMSRGProfiler.html">IMSRGProfiler</a>&#160;</td><td class="memItemRight" valign="bottom"><b>profiler</b></td></tr>
<tr class="memdesc:a0435b3f1485ddd1d8d91bbd84e008445"><td class="mdescLeft">&#160;</td><td class="mdescRight">Profiler for timing, etc. <br /></td></tr>
<tr class="separator:a0435b3f1485ddd1d8d91bbd84e008445"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42d87e7ce2ad6e56d12063a62ff91bf9"><td class="memItemLeft" align="right" valign="top"><a id="a42d87e7ce2ad6e56d12063a62ff91bf9" name="a42d87e7ce2ad6e56d12063a62ff91bf9"></a>
std::deque&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>convergence_ediff</b></td></tr>
<tr class="memdesc:a42d87e7ce2ad6e56d12063a62ff91bf9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Save last few convergence checks for diagnostics. <br /></td></tr>
<tr class="separator:a42d87e7ce2ad6e56d12063a62ff91bf9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1366b8f034fb0feb9aed43480398f54"><td class="memItemLeft" align="right" valign="top"><a id="ac1366b8f034fb0feb9aed43480398f54" name="ac1366b8f034fb0feb9aed43480398f54"></a>
std::deque&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>convergence_EHF</b></td></tr>
<tr class="memdesc:ac1366b8f034fb0feb9aed43480398f54"><td class="mdescLeft">&#160;</td><td class="mdescRight">Save last few convergence checks for diagnostics. <br /></td></tr>
<tr class="separator:ac1366b8f034fb0feb9aed43480398f54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af01bb74d202e6f5918bc8ec5ce36c306"><td class="memItemLeft" align="right" valign="top"><a id="af01bb74d202e6f5918bc8ec5ce36c306" name="af01bb74d202e6f5918bc8ec5ce36c306"></a>
std::deque&lt; arma::mat &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>DIIS_density_mats</b></td></tr>
<tr class="memdesc:af01bb74d202e6f5918bc8ec5ce36c306"><td class="mdescLeft">&#160;</td><td class="mdescRight">Save density matrix from past iterations for DIIS. <br /></td></tr>
<tr class="separator:af01bb74d202e6f5918bc8ec5ce36c306"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8056ec7194c14d20693f7c43f4a10ce"><td class="memItemLeft" align="right" valign="top"><a id="ae8056ec7194c14d20693f7c43f4a10ce" name="ae8056ec7194c14d20693f7c43f4a10ce"></a>
std::deque&lt; arma::mat &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>DIIS_error_mats</b></td></tr>
<tr class="memdesc:ae8056ec7194c14d20693f7c43f4a10ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Save error from past iterations for DIIS. <br /></td></tr>
<tr class="separator:ae8056ec7194c14d20693f7c43f4a10ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11c6d05093805dee7e8364fd02fc302f"><td class="memItemLeft" align="right" valign="top"><a id="a11c6d05093805dee7e8364fd02fc302f" name="a11c6d05093805dee7e8364fd02fc302f"></a>
<a class="el" href="classJacobi3BME.html">Jacobi3BME</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>jacobi3bme</b></td></tr>
<tr class="memdesc:a11c6d05093805dee7e8364fd02fc302f"><td class="mdescLeft">&#160;</td><td class="mdescRight">pointer to 3-body matrix elements in jacobi basis, if we want to use that <br /></td></tr>
<tr class="separator:a11c6d05093805dee7e8364fd02fc302f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a968072110d17ad73e143b92abc215fab"><td class="memItemLeft" align="right" valign="top"><a id="a968072110d17ad73e143b92abc215fab" name="a968072110d17ad73e143b92abc215fab"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>use_jacobi_3body</b></td></tr>
<tr class="separator:a968072110d17ad73e143b92abc215fab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5dba3b4a2fd164c68daeb7a744ede3c6"><td class="memItemLeft" align="right" valign="top"><a id="a5dba3b4a2fd164c68daeb7a744ede3c6" name="a5dba3b4a2fd164c68daeb7a744ede3c6"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>freeze_occupations</b></td></tr>
<tr class="separator:a5dba3b4a2fd164c68daeb7a744ede3c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf8d88d76b3462cc2578a762977ca7ca"><td class="memItemLeft" align="right" valign="top"><a id="aaf8d88d76b3462cc2578a762977ca7ca" name="aaf8d88d76b3462cc2578a762977ca7ca"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>discard_NO2B_from_3N</b></td></tr>
<tr class="separator:aaf8d88d76b3462cc2578a762977ca7ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a3d6bac9b4403e4bc599a89ad0c9b6056" name="a3d6bac9b4403e4bc599a89ad0c9b6056"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d6bac9b4403e4bc599a89ad0c9b6056">&#9670;&#160;</a></span>BuildMonopoleV()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void HartreeFock::BuildMonopoleV </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Only the monopole part of V is needed, so construct it. </p>
<p>Construct an unnormalized two-body monopole interaction  </p><p class="formulaDsp">
\[ \langle ab | \bar{V}^{(2)} | cd \rangle
  = \sqrt{(1+\delta_{ab})(1+\delta_{cd})} \sum_{J} (2J+1) \langle ab | V^{(2)} | cd \rangle_{J} \]
</p>
<p> This method utilizes the operator method <a class="el" href="classTwoBodyME.html#a41e1d7a520f31b57283b7817a35bceb7">TwoBodyME::GetTBMEmonopole()</a> </p>

</div>
</div>
<a id="a1c146af25a09f427cc626d877ec6e518" name="a1c146af25a09f427cc626d877ec6e518"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c146af25a09f427cc626d877ec6e518">&#9670;&#160;</a></span>BuildMonopoleV3()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void HartreeFock::BuildMonopoleV3 </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Only the monopole part of V3 is needed. </p>
<p>Construct an unnormalized three-body monopole interaction  </p><p class="formulaDsp">
\[ \langle iab | \bar{V}^{(3)} | jcd \rangle =
    \sum\limits_{J,J_{12}}\sum_{Tt_{12}}(2J+1)(2T+1)
      \langle (ia)J_{12}t_{12};b JT| V^{(3)} | (jc)J_{12}t_{12}; d JT\rangle
\]
</p>
 
</div>
</div>
<a id="a0a1bd3a195362c73e6c9e10a38fcb13b" name="a0a1bd3a195362c73e6c9e10a38fcb13b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a1bd3a195362c73e6c9e10a38fcb13b">&#9670;&#160;</a></span>BuildMonopoleV3Jacobi()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void HartreeFock::BuildMonopoleV3Jacobi </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct directly from the Jacobi 3-body matrix elements. </p>
<p>Construct the V3 monopole matrix elements directly from the jacobi matrix elements. So far this is completely untested and certainly wrong. </p>

</div>
</div>
<a id="aef506c5c5bc0f317ceb9c71bdc44d62b" name="aef506c5c5bc0f317ceb9c71bdc44d62b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aef506c5c5bc0f317ceb9c71bdc44d62b">&#9670;&#160;</a></span>CalcEHF()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void HartreeFock::CalcEHF </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Evaluate the Hartree Fock energy. </p>
<p>Calculate the HF energy.  </p><p class="formulaDsp">
\begin{eqnarray*} E_{HF} &amp;=&amp; \sum_{\alpha} t_{\alpha\alpha}
                   + \frac{1}{2}\sum_{\alpha\beta} V_{\alpha\beta\alpha\beta}
                   + \frac{1}{6}\sum_{\alpha\beta\gamma} V_{\alpha\beta\gamma\alpha\beta\gamma} \\
   &amp;=&amp; \sum_{ij} (2j_i+1) \rho_{ij} ( t_{ij} +\frac{1}{2}\tilde{V}^{(2)}_{ij} + \frac{1}{6}\tilde{V}^{(3)}_{ij} )
\end{eqnarray*}
</p>
<p> Where the matrices </p><p class="formulaDsp">
\begin{eqnarray*}
 \tilde{V}^{(2)}_{ij} &amp;=&amp; \sum_{ab} \rho_{ab}\bar{V}^{(2)}_{iajb} \\
 \tilde{V}^{(3)}_{ij} &amp;=&amp; \sum_{abcd} \rho_{ab}\rho_{cd} \bar{V}^{(3)}_{iacjbd} \\
\end{eqnarray*}
</p>
<p> have already been calculated by <a class="el" href="classHartreeFock.html#a84fe0eb16f6e5835c920bf8fa98c4442" title="Update the Fock matrix with the new transformation coefficients C.">UpdateF()</a>. </p>

</div>
</div>
<a id="a35ab9c4f96e68b1c9acea1d1407ecc60" name="a35ab9c4f96e68b1c9acea1d1407ecc60"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a35ab9c4f96e68b1c9acea1d1407ecc60">&#9670;&#160;</a></span>CheckConvergence()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool HartreeFock::CheckConvergence </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compare the current energies with those from the previous iteration. </p>
<p>Check for convergence using difference in s.p. energies between iterations. Converged when </p><p class="formulaDsp">
\[ \delta_{e} \equiv \sqrt{ \sum_{i}(e_{i}^{(n)}-e_{i}^{(n-1)})^2} &lt; \textrm{tolerance} \]
</p>
<p> where \( e_{i}^{(n)} \) is the \( i \)th eigenvalue of the Fock matrix after \( n \) iterations. </p>

</div>
</div>
<a id="a00f7b0c4cb7373a3f1a69ca27a4dfaed" name="a00f7b0c4cb7373a3f1a69ca27a4dfaed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a00f7b0c4cb7373a3f1a69ca27a4dfaed">&#9670;&#160;</a></span>Diagonalize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void HartreeFock::Diagonalize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Diagonalize the Fock matrix. </p>
<p>[See Suhonen eq. 4.85] Diagonalize the fock matrix \( &lt;a|F|b&gt; \) and put the eigenvectors in \(C(i,\alpha) = &lt;i|\alpha&gt; \) and eigenvalues in the vector energies. Save the last vector of energies to check for convergence. Submatrices corresponding to different channels are diagonalized independently. This guarantees that J,Tz, and \( \pi \) remain good. </p>

</div>
</div>
<a id="a74c842cbf4e8caec72591c1205794f1f" name="a74c842cbf4e8caec72591c1205794f1f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a74c842cbf4e8caec72591c1205794f1f">&#9670;&#160;</a></span>FillLowestOrbits()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void HartreeFock::FillLowestOrbits </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get new occupations based on the current single-particle energies. </p>
<p>Get new occupation numbers by filling the orbits in order of their single-particle energies. The last proton/neutron orbit can have a fractional filling, corresponding to ensemble normal ordering. </p>

</div>
</div>
<a id="aef3c1b45c5418ead19f258774a301f83" name="aef3c1b45c5418ead19f258774a301f83"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aef3c1b45c5418ead19f258774a301f83">&#9670;&#160;</a></span>FreeVmon()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void HartreeFock::FreeVmon </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Free up the memory used to store Vmon3. </p>
<p>Not sure if this is actually helpful. Memory management is a mystery to me. </p>

</div>
</div>
<a id="a212670984cab16c79f1c4cfd376f8e3d" name="a212670984cab16c79f1c4cfd376f8e3d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a212670984cab16c79f1c4cfd376f8e3d">&#9670;&#160;</a></span>GetHFPotential()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double HartreeFock::GetHFPotential </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>rprime</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The effective one-body Hartree-Fock potential for an orbit with quantum numbers l,j,tz. This is a non-local potential, i.e. it depends on r and r'. </p>

</div>
</div>
<a id="a5aa5a7db5250b37f6e2527c470bd1164" name="a5aa5a7db5250b37f6e2527c470bd1164"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5aa5a7db5250b37f6e2527c470bd1164">&#9670;&#160;</a></span>GetNormalOrderedH() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classOperator.html">Operator</a> HartreeFock::GetNormalOrderedH </td>
          <td>(</td>
          <td class="paramtype">arma::mat &amp;&#160;</td>
          <td class="paramname"><em>Cin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>particle_rank</em> = <code>2</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the Hamiltonian in the HF basis at the normal-ordered 2body level. </p>
<p>Returns the Hamiltonian normal ordered with respect to the reference in the basis defined by Cin, where Cin is a transformation from the original basis (typically the harmonic oscillator). </p>

</div>
</div>
<a id="af548b32924c2dfcd885ca0ba95525a82" name="af548b32924c2dfcd885ca0ba95525a82"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af548b32924c2dfcd885ca0ba95525a82">&#9670;&#160;</a></span>GetNormalOrderedH() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classOperator.html">Operator</a> HartreeFock::GetNormalOrderedH </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>particle_rank</em> = <code>2</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the Hamiltonian in the HF basis at the normal-ordered 2body level. </p>
<p>Returns the normal-ordered Hamiltonian in the Hartree-Fock basis, neglecting the residual 3-body piece. </p><p class="formulaDsp">
\[ E_0 = E_{HF} \]
</p>
 <p class="formulaDsp">
\[ f = C^{\dagger} F C \]
</p>
 <p class="formulaDsp">
\[ \Gamma = D^{\dagger} \left(V^{(2)}+V^{(3\rightarrow 2)} \right) D \]
</p>
 <p class="formulaDsp">
\[ V^{(2\rightarrow 3)J}_{ijkl} \equiv \frac{1}{\sqrt{(1+\delta_{ij})(1+\delta_{kl})}}\sum_{ab}\sum_{J_3}(2J_{3}+1)\rho_{ab}V^{JJJ_{3}}_{ijaklb} \]
</p>
<p> Where \( F\) is the Fock matrix obtained in <a class="el" href="classHartreeFock.html#a84fe0eb16f6e5835c920bf8fa98c4442" title="Update the Fock matrix with the new transformation coefficients C.">UpdateF()</a> and the matrix \( D\) is the same as the one defined in <a class="el" href="classHartreeFock.html#a55914915cea16669e549025c244b62d0" title="Transform an operator from oscillator basis to HF basis.">TransformToHFBasis()</a>. </p>

</div>
</div>
<a id="a53011b381945ed5c61f50b209db5bf64" name="a53011b381945ed5c61f50b209db5bf64"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a53011b381945ed5c61f50b209db5bf64">&#9670;&#160;</a></span>GetOmega()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classOperator.html">Operator</a> HartreeFock::GetOmega </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a generator of the Hartree Fock transformation. </p>
<p>Get the one-body generator corresponding to the transformation to the HF basis. Since the unitary transformation for HF is given by the \( U_{HF} = C^{\dagger} \) matrix, we have \( e^{-\Omega} = C \Rightarrow \Omega = -\log(C) \). The log is evaluated by diagonalizing the one-body submatrix and taking the log of the diagonal entries. This is much slower than the other methods, but it might be useful for debugging/benchmarking. </p>

</div>
</div>
<a id="a29de897a332985f5b08bd0f08a466db3" name="a29de897a332985f5b08bd0f08a466db3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a29de897a332985f5b08bd0f08a466db3">&#9670;&#160;</a></span>GetRadialWF_r()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double HartreeFock::GetRadialWF_r </td>
          <td>(</td>
          <td class="paramtype">index_t&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>R</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the radial wave function of an orbit in the HF basis. </p>
<p>Get the radial wave function of an orbit in the HF basis at point R. It is assumed that the input basis is the harmonic oscillator. </p>

</div>
</div>
<a id="aefe4589d4659b6c18e75d8029d8293dd" name="aefe4589d4659b6c18e75d8029d8293dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aefe4589d4659b6c18e75d8029d8293dd">&#9670;&#160;</a></span>GetTransformed3B()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classThreeBodyME.html">ThreeBodyME</a> HartreeFock::GetTransformed3B </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classOperator.html">Operator</a> &amp;&#160;</td>
          <td class="paramname"><em>OpIn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">arma::mat &amp;&#160;</td>
          <td class="paramname"><em>C_3b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>In most standard calculations, we take the NO2B approximation after the HF step, so we don't need this. However, if we want to use the residual 3-body in any post-HF steps, we need to transform it to the HF basis. </p>

</div>
</div>
<a id="a2c3bdda2ea86f9a3b18d203c9aecc353" name="a2c3bdda2ea86f9a3b18d203c9aecc353"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c3bdda2ea86f9a3b18d203c9aecc353">&#9670;&#160;</a></span>PrintEHF()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void HartreeFock::PrintEHF </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Print out the Hartree Fock energy. </p>
<p>Print out the Hartree Fock energy, and the 1-, 2-, and 3-body contributions to it. </p>

</div>
</div>
<a id="ab96b85eca26bf7c57430242201066932" name="ab96b85eca26bf7c57430242201066932"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab96b85eca26bf7c57430242201066932">&#9670;&#160;</a></span>PrintSPE()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void HartreeFock::PrintSPE </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Getter function for Hbare. </p>
<p>Print out the single particle orbits with their energies.</p>
<p>Print out the single-particle energies </p>

</div>
</div>
<a id="a51d5163a8df635593edbeaa531aa5a34" name="a51d5163a8df635593edbeaa531aa5a34"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a51d5163a8df635593edbeaa531aa5a34">&#9670;&#160;</a></span>PrintSPEandWF()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void HartreeFock::PrintSPEandWF </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Print out the single-particle energies and wave functions. </p>
<p>Print out the single particle orbits with their energies, as well as the overlap with the input (oscillator) basis states </p>

</div>
</div>
<a id="a2eb6754f57250a03a2e1bd3e2aef4daf" name="a2eb6754f57250a03a2e1bd3e2aef4daf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2eb6754f57250a03a2e1bd3e2aef4daf">&#9670;&#160;</a></span>ReorderCoefficients()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void HartreeFock::ReorderCoefficients </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reorder the coefficients in C to eliminate phases etc. </p>
<p>Eigenvectors/values come out of the diagonalization energy-ordered. We want them ordered corresponding to the input ordering, i.e. we want the l,j,tz sub-blockes of the matrix C to be energy-ordered and positive along the diagonal. For a 3x3 matrix this would be something like (this needs to be updated)  </p><p class="formulaDsp">
\[
\left(
\begin{array}{rrr}
  -0.8 &amp; 0.2 &amp; -0.6 \\
  -0.3 &amp; 0.3 &amp;  0.9 \\
   0.2 &amp; 0.9 &amp; -0.4 \\
\end{array}\right)
\rightarrow
\left(\begin{array}{rrr}
   0.8 &amp; -0.6 &amp; 0.2  \\
   0.3 &amp;  0.9 &amp; 0.3  \\
  -0.2 &amp; -0.4 &amp; 0.9  \\
\end{array}\right)
\]
</p>
 
</div>
</div>
<a id="ac74c8fb568eae94cb191bf3fa7cad574" name="ac74c8fb568eae94cb191bf3fa7cad574"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac74c8fb568eae94cb191bf3fa7cad574">&#9670;&#160;</a></span>SetModelspaceForOutput3N()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void HartreeFock::SetModelspaceForOutput3N </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classModelSpace.html">ModelSpace</a> &amp;&#160;</td>
          <td class="paramname"><em>ms</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set a different modelspace for the output 3N upon transforming to the HF basis. This might be useful if we do the HF step with a large 3N space, and then want to do IMSRG(3) in a smaller 3N space. This way we can avoid transforming 3N matrix elements that we then immediately discard. </p>

</div>
</div>
<a id="a608db2a6188579180d6fc51230a4aa3e" name="a608db2a6188579180d6fc51230a4aa3e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a608db2a6188579180d6fc51230a4aa3e">&#9670;&#160;</a></span>SetUpMonopoleV3Keys()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void HartreeFock::SetUpMonopoleV3Keys </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Figure out the needed monopole terms. </p>
<p>Set up the keys for the 3-body monopole terms We do this separately because it's fast (so it doesn't need to be parallel) and because it's the same whether we use lab frame 3N or jacobi 3N. </p>

</div>
</div>
<a id="a0666507747c17845ab4f74b97414703c" name="a0666507747c17845ab4f74b97414703c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0666507747c17845ab4f74b97414703c">&#9670;&#160;</a></span>Solve()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void HartreeFock::Solve </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Diagonalize and UpdateF until convergence. </p>
<p>Diagonalize and update the Fock matrix until convergence. Then, call <a class="el" href="classHartreeFock.html#a2eb6754f57250a03a2e1bd3e2aef4daf" title="Reorder the coefficients in C to eliminate phases etc.">ReorderCoefficients()</a> to make sure the index ordering and phases are preserved in the transformation from the original basis to the Hatree-Fock basis. </p>

</div>
</div>
<a id="a55914915cea16669e549025c244b62d0" name="a55914915cea16669e549025c244b62d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a55914915cea16669e549025c244b62d0">&#9670;&#160;</a></span>TransformToHFBasis()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classOperator.html">Operator</a> HartreeFock::TransformToHFBasis </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classOperator.html">Operator</a> &amp;&#160;</td>
          <td class="paramname"><em>OpHO</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Transform an operator from oscillator basis to HF basis. </p>
<p>Takes in an operator expressed in the basis of the original Hamiltonian, and returns that operator in the Hartree-Fock basis. </p><p class="formulaDsp">
\[ t_{HF} = C^{\dagger} t_{HO} C \]
</p>
 <p class="formulaDsp">
\[ V_{HF}^{J} = D^{\dagger} V^{J}_{HO} D \]
</p>
<p> The matrix \( D \) is defined as </p><p class="formulaDsp">
\[ D_{ab\alpha\beta} \equiv \sqrt{ \frac{1+\delta_{ab}} {1+\delta_{\alpha\beta}} }  C_{a\alpha} C_{b\beta} \]
</p>
<p> The factor in the square root is due to the fact that we're using normalized TBME's. Since only kets with \( a\leq b\) are stored, we can use the antisymmetry of the TBME's and define  </p><p class="formulaDsp">
\[ D(J)_{ab\alpha\beta} \equiv \sqrt{ \frac{1+\delta_{ab}} {1+\delta_{\alpha\beta}} }
     \left( C_{a\alpha} C_{b\beta} -(1-\delta_{ab})(-1)^{j_a+j_b-J} C_{b\alpha}C_{a\beta}\right) \]
</p>
 
</div>
</div>
<a id="aad38c905e7e9f9e9757b5800e6910c61" name="aad38c905e7e9f9e9757b5800e6910c61"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad38c905e7e9f9e9757b5800e6910c61">&#9670;&#160;</a></span>UpdateDensityMatrix()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void HartreeFock::UpdateDensityMatrix </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Update the density matrix with the new coefficients C. </p>
<p>one-body density matrix \( &lt;i|\rho|j&gt; = \sum\limits_{\beta} n_{\beta} &lt;i|\beta&gt; &lt;\beta|j&gt; \) where \(n_{\beta} \) ensures that beta runs over HF orbits in the core (i.e. below the fermi surface) </p>

</div>
</div>
<a id="a84fe0eb16f6e5835c920bf8fa98c4442" name="a84fe0eb16f6e5835c920bf8fa98c4442"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a84fe0eb16f6e5835c920bf8fa98c4442">&#9670;&#160;</a></span>UpdateF()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void HartreeFock::UpdateF </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Update the Fock matrix with the new transformation coefficients C. </p>
<p>[See Suhonen eq 4.85]  </p><p class="formulaDsp">
\[ F_{ij} = t_{ij}  +  \frac{1}{2j_i+1}\sum_{ab} \rho_{ab} \bar{V}^{(2)}_{iajb}
              + \frac{1}{2(2j_i+1)}\sum_{abcd}\rho_{ab} \rho_{cd} \bar{V}^{(3)}_{iacjbd}  \]
</p>
<ul>
<li>\( F \) is the Fock matrix, to be diagonalized</li>
<li>\( t \) is the kinetic energy</li>
<li>\(\rho\) is the density matrix defined in <a class="el" href="classHartreeFock.html#aad38c905e7e9f9e9757b5800e6910c61" title="Update the density matrix with the new coefficients C.">UpdateDensityMatrix()</a></li>
<li>\( \bar{V}^{(2)} \) is the monopole component of the 2-body interaction defined in <a class="el" href="classHartreeFock.html#a3d6bac9b4403e4bc599a89ad0c9b6056" title="Only the monopole part of V is needed, so construct it.">BuildMonopoleV()</a>.</li>
<li>\( \bar{V}^{(3)} \) is the monopole component of the 3-body interaction devined in <a class="el" href="classHartreeFock.html#a1c146af25a09f427cc626d877ec6e518" title="Only the monopole part of V3 is needed.">BuildMonopoleV3()</a>. </li>
</ul>

</div>
</div>
<a id="af7dbc7d8aa192f192f23347c46ad084c" name="af7dbc7d8aa192f192f23347c46ad084c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af7dbc7d8aa192f192f23347c46ad084c">&#9670;&#160;</a></span>UpdateReference()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void HartreeFock::UpdateReference </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>If we got new occupations in FillLowestOrbits, then we should update the hole states in the reference. </p>
<p>If the lowest orbits are different from our previous guess, we should update the reference. </p>

</div>
</div>
<a id="ab863d5d020e15854d4d591ec0ce6a1a0" name="ab863d5d020e15854d4d591ec0ce6a1a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab863d5d020e15854d4d591ec0ce6a1a0">&#9670;&#160;</a></span>Vmon3Hash()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t HartreeFock::Vmon3Hash </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Hashing function for rolling six orbit indices into a single long unsigned int. Each orbit gets 10 bits. </p>

</div>
</div>
<a id="ab9b00d4cece0e9424b09bd5faaef8276" name="ab9b00d4cece0e9424b09bd5faaef8276"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab9b00d4cece0e9424b09bd5faaef8276">&#9670;&#160;</a></span>Vmon3JacobiHash()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t HartreeFock::Vmon3JacobiHash </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>na</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>nb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>nc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>Jab</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>twoJ</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>E12</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>Ncm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>Lcm</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Hashing function for rolling nine indices into a single long unsigned int. Each n value get 5 bits, which means they should be less than 32 (emax=64, probably ok for the near future) Jab gets 6 bits, twoJ gets 7 bits, Lcm gets 7 bits, Ncm gets 6 bits, E12 gets 7 bits leaving 16 bits for alpha, which is hopefully (?) enough. </p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a415fc1fbbba3a6a84d47e31ed18323c9" name="a415fc1fbbba3a6a84d47e31ed18323c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a415fc1fbbba3a6a84d47e31ed18323c9">&#9670;&#160;</a></span>energies</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">arma::vec HartreeFock::energies</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>occupations of hole orbits </p>
<p>vector of single particle energies </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li><a class="el" href="HartreeFock_8hh_source.html">HartreeFock.hh</a></li>
<li>HartreeFock.cc</li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Fri Jul 21 2023 22:18:59 for IM-SRG++ by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.7
</small></address>
</body>
</html>
